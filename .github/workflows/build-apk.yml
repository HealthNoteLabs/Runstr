name: Build, Sign and Release to Zap.Store

on:
  push:
    branches:
      - Simple-updates
      - updates1 # Added feed branch to automatically trigger the workflow
  workflow_dispatch:  # Allows manual triggering

jobs:
  build:
    name: Build, Sign and Release APK
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      # Extract version from package.json
      - name: Get Version from package.json
        id: package_version
        run: echo "VERSION=$(jq -r .version package.json)" >> $GITHUB_ENV

      # Generate timestamp for uniqueness
      - name: Generate Timestamp
        id: timestamp
        run: echo "DATE=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_ENV

      # Generate release tag dynamically
      - name: Generate Release Tag
        id: release_tag
        run: echo "RELEASE_TAG=feed-${{ env.VERSION }}-${{ env.DATE }}" >> $GITHUB_ENV

      # Build the React app
      - name: Build React app
        run: npm run build

      # Install Capacitor CLI if not installed globally
      - name: Install Capacitor CLI
        run: npm install -g @capacitor/cli

      # Sync React build with Android platform
      - name: Sync Capacitor with Android
        run: npx cap sync android

      # Setup Java for Android build - changed to JDK 17 for compatibility with Zap.Store
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Verify JDK version and make sure it's visible
      - name: Verify Java version
        run: |
          echo "JAVA_HOME=$JAVA_HOME"
          echo "PATH=$PATH"
          echo "Java version:"
          java -version
          echo "Javac version:"
          javac -version
          echo "All java installations:"
          which java || echo "No java found"
          ls -la $JAVA_HOME/bin/ || echo "No JAVA_HOME/bin directory"

      # Setup Android SDK
      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      # Grant execute permissions for Gradle wrapper
      - name: Grant execute permission to Gradle wrapper
        run: chmod +x ./android/gradlew

      # Fix Java version - simplified approach
      - name: Prepare Java 17 environment
        run: |
          echo "=== Setting up Java 17 compatibility ==="
          
          # Create gradle.properties with Java 17 settings
          cat > android/gradle.properties << EOF
          # Java 17 settings
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 --add-opens java.base/java.io=ALL-UNNAMED
          org.gradle.java.home=${JAVA_HOME}
          android.useAndroidX=true
          kotlin.jvm.target.validation.mode=warning
          # Debug settings
          org.gradle.logging.level=debug
          EOF
          
          echo "=== Java setup complete ==="

      # Generate keystore for signing
      - name: Generate Keystore
        id: generate_keystore
        run: |
          # Generate keystore directly for signing
          echo "${{ secrets.SIGNING_KEY_BASE64 || '' }}" > release.keystore.base64
          # If we have a key base64, decode it
          if [ -s release.keystore.base64 ]; then
            # Platform-independent base64 decode
            if [ "$(uname)" == "Darwin" ]; then
              # macOS
              base64 -D -i release.keystore.base64 -o release.keystore
            else
              # Linux and others
              base64 -d release.keystore.base64 > release.keystore
            fi
          else
            # Generate a new keystore if no base64 key is provided
            keytool -genkey -v -keystore release.keystore -alias ${{ secrets.KEY_ALIAS }} -keyalg RSA -keysize 2048 -validity 10000 -storepass ${{ secrets.KEY_STORE_PASSWORD }} -keypass ${{ secrets.KEY_PASSWORD }} -dname "cn=Unknown, ou=Unknown, o=Unknown, c=US"
            # Platform-independent base64 encode
            if [ "$(uname)" == "Darwin" ]; then
              # macOS
              base64 -i release.keystore -o release.keystore.base64
            else
              # Linux and others
              base64 release.keystore > release.keystore.base64
            fi
          fi
          # Set the keystore base64 as an output and remove newlines
          echo "keystore_base64=$(cat release.keystore.base64 | tr -d '\n')" >> $GITHUB_OUTPUT
          echo "Keystore size: $(wc -c release.keystore | awk '{print $1}') bytes"

      # Build Release APK instead of Debug
      - name: Build Release APK
        id: build_apk
        continue-on-error: true  # Changed to true so we can see where files are created
        run: |
          cd android
          
          # Print detailed info for debugging
          echo "==== ENVIRONMENT INFO ===="
          echo "JAVA_HOME = $JAVA_HOME"
          echo "Android SDK = $ANDROID_SDK_ROOT"
          echo "=========================="
          
          # Try building with detailed output
          ./gradlew --no-daemon --debug \
            -Dorg.gradle.java.home="$JAVA_HOME" \
            assembleRelease
          
          # Check where the APK was actually built
          echo "==== LOCATING APK FILES ===="
          find . -name "*.apk" | sort

      # Properly locate and prepare APK for signing
      - name: Locate and Prepare APK for Signing
        id: locate_apk
        run: |
          echo "Searching for APK files in the Android project..."
          
          # Create the expected directory
          mkdir -p android/app/build/outputs/apk/release
          
          # First, try to find APK in expected release location
          APK_FILES=$(find android -name "*.apk" | grep -v "debug" | sort)
          
          if [ -z "$APK_FILES" ]; then
            echo "No release APK found, looking for any APK..."
            APK_FILES=$(find android -name "*.apk")
          fi
          
          if [ -z "$APK_FILES" ]; then
            echo "::error::No APK files found at all. Build may have failed."
            exit 1
          fi
          
          echo "Found these APK files:"
          echo "$APK_FILES"
          
          # Copy the first APK found to the expected location
          FIRST_APK=$(echo "$APK_FILES" | head -n 1)
          echo "Using APK: $FIRST_APK"
          
          # Copy to the standard location expected by the sign-android-release action
          cp "$FIRST_APK" android/app/build/outputs/apk/release/app-release-unsigned.apk
          
          # Verify it's there
          ls -la android/app/build/outputs/apk/release/
          
          echo "APK prepared for signing at: android/app/build/outputs/apk/release/app-release-unsigned.apk"
          echo "apk_path=android/app/build/outputs/apk/release" >> $GITHUB_OUTPUT

      # Verify APK exists before signing - we don't need this anymore since we've handled it in the locate_apk step
      - name: Sign APK
        id: sign_app
        uses: r0adkll/sign-android-release@v1
        with:
          releaseDirectory: ${{ steps.locate_apk.outputs.apk_path }}
          signingKeyBase64: ${{ steps.generate_keystore.outputs.keystore_base64 }}
          alias: ${{ secrets.KEY_ALIAS }}
          keyStorePassword: ${{ secrets.KEY_STORE_PASSWORD }}
          keyPassword: ${{ secrets.KEY_PASSWORD }}
        env:
          BUILD_TOOLS_VERSION: "34.0.0"
          
      # Verify signed APK exists
      - name: Verify Signed APK
        run: |
          if [ -z "${{ steps.sign_app.outputs.signedReleaseFile }}" ]; then
            echo "::error::No signed APK was produced. Check signing step output."
            exit 1
          else
            echo "Signed APK successfully created at: ${{ steps.sign_app.outputs.signedReleaseFile }}"
            ls -la "${{ steps.sign_app.outputs.signedReleaseFile }}"
          fi

      # Create a Release
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          release_name: 'Release ${{ env.RELEASE_TAG }}'
          draft: false
          prerelease: true

      # Upload Signed APK to Release
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.sign_app.outputs.signedReleaseFile }}
          asset_name: app-release-signed.apk
          asset_content_type: application/vnd.android.package-archive

      # Setup for Zap.Store publishing
      - name: Setup Dart SDK
        uses: dart-lang/setup-dart@v1.6.5
      
      - name: Install Apktool
        run: |
          wget "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool"
          wget "https://github.com/iBotPeaches/Apktool/releases/download/v2.10.0/apktool_2.10.0.jar"
          mv apktool_2.10.0.jar apktool.jar
          sudo cp apktool /usr/local/bin
          sudo cp apktool.jar /usr/local/bin
          sudo chmod +x /usr/local/bin/apktool
          sudo chmod +x /usr/local/bin/apktool.jar
      
      - name: Get Zap.Store CLI
        run: |
          mkdir -p /home/runner/.zapstore
          git clone https://github.com/zapstore/zapstore-cli.git
          cd zapstore-cli
          git fetch --tags
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/zapstore/zapstore-cli/releases/latest)
          TAG_NAME=$(echo $LATEST_RELEASE | jq -r .tag_name)
          git checkout $TAG_NAME
          dart pub get
          dart compile exe lib/main.dart -o build
      
      - name: Publish to Zap.Store
        env:
          NSEC: ${{ secrets.NSEC }}
        run: |
          cd $GITHUB_WORKSPACE
          APKSIGNER_PATH=$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner ./zapstore-cli/build publish "RUNSTR"