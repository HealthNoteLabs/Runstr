name: Build, Sign and Release to Zap.Store

on:
  push:
    branches:
      - Simple-updates
      - updates1 # Added feed branch to automatically trigger the workflow
  workflow_dispatch:  # Allows manual triggering

jobs:
  build:
    name: Build, Sign and Release APK
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      # Extract version from package.json
      - name: Get Version from package.json
        id: package_version
        run: echo "VERSION=$(jq -r .version package.json)" >> $GITHUB_ENV

      # Generate timestamp for uniqueness
      - name: Generate Timestamp
        id: timestamp
        run: echo "DATE=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_ENV

      # Generate release tag dynamically
      - name: Generate Release Tag
        id: release_tag
        run: echo "RELEASE_TAG=feed-${{ env.VERSION }}-${{ env.DATE }}" >> $GITHUB_ENV

      # Build the React app
      - name: Build React app
        run: npm run build

      # Install Capacitor CLI if not installed globally
      - name: Install Capacitor CLI
        run: npm install -g @capacitor/cli

      # Generate keystore for signing
      - name: Generate Keystore
        id: generate_keystore
        run: |
          echo "==== GENERATING NEW KEYSTORE ===="
          # Print current directory for debugging
          echo "Current directory: $(pwd)"
          
          echo "Generating new keystore for signing..."
          keytool -genkey -v -keystore release.keystore \
            -alias ${{ secrets.KEY_ALIAS }} \
            -keyalg RSA -keysize 2048 -validity 10000 \
            -storepass ${{ secrets.KEY_STORE_PASSWORD }} \
            -keypass ${{ secrets.KEY_PASSWORD }} \
            -dname "cn=Unknown, ou=Unknown, o=Unknown, c=US"
          
          # Verify keystore was created
          if [ -f "release.keystore" ]; then
            echo "✅ Keystore file created successfully"
            echo "Keystore size: $(wc -c release.keystore | awk '{print $1}') bytes"
            ls -la release.keystore
            
            # Generate base64 for signing step
            base64 release.keystore > release.keystore.base64
            
            # Make a copy of the keystore in android/app/ directory
            mkdir -p android/app/
            cp release.keystore android/app/release.keystore
            echo "Copied keystore to android/app/release.keystore"
            
            # Set the keystore base64 as an output and remove newlines
            echo "keystore_base64=$(cat release.keystore.base64 | tr -d '\n')" >> $GITHUB_OUTPUT
          else
            echo "❌ FAILED to create keystore file!"
            exit 1
          fi
          
          echo "==== KEYSTORE GENERATION COMPLETE ===="

      # Sync React build with Android platform
      - name: Sync Capacitor with Android
        run: npx cap sync android

      # Prepare Android project
      - name: Prepare Android Project
        run: |
          echo "==== PREPARING ANDROID PROJECT ===="
          
          # Print current directory for debugging
          echo "Current directory: $(pwd)"
          
          # Verify android directory exists
          ls -la
          
          # Check if android/ directory exists
          if [ ! -d "android" ]; then
            echo "ERROR: Android directory not found. Did capacitor sync fail?"
            exit 1
          fi
          
          # Check app/build.gradle exists
          if [ ! -f "android/app/build.gradle" ]; then
            echo "ERROR: android/app/build.gradle not found. Project structure issue."
            ls -la android/
            exit 1
          fi
          
          # Ensure signing config exists in build.gradle
          echo "Checking signing config in build.gradle..."
          if ! grep -q "signingConfigs" android/app/build.gradle; then
            echo "Adding signing configuration to build.gradle"
            
            # Create backup
            cp android/app/build.gradle android/app/build.gradle.bak
            
            # Inject signing config
            sed -i '/defaultConfig {/,/}/a\\n    signingConfigs {\n        release {\n            storeFile file("release.keystore")\n            storePassword "'${{ secrets.KEY_STORE_PASSWORD }}'"\n            keyAlias "'${{ secrets.KEY_ALIAS }}'"\n            keyPassword "'${{ secrets.KEY_PASSWORD }}'"\n        }\n    }' android/app/build.gradle
            
            # Reference signing config in buildTypes
            sed -i '/release {/,/}/s/}/    signingConfig signingConfigs.release\n}/' android/app/build.gradle
          else
            echo "Signing config already exists in build.gradle"
          fi
          
          # Verify keystore file exists in android/app/
          if [ -f "android/app/release.keystore" ]; then
            echo "✅ Keystore file exists in android/app/"
          else
            echo "WARNING: Keystore not found in android/app/, copying again..."
            cp release.keystore android/app/release.keystore
          fi
          
          # Create keystore.properties (as an additional way to provide keystore info)
          echo "Creating keystore.properties..."
          cat > android/keystore.properties << EOF
          storePassword=${{ secrets.KEY_STORE_PASSWORD }}
          keyPassword=${{ secrets.KEY_PASSWORD }}
          keyAlias=${{ secrets.KEY_ALIAS }}
          storeFile=release.keystore
          EOF
          
          echo "==== ANDROID PROJECT READY ===="

      # Setup Java for Android build - changed to JDK 17 for compatibility with Zap.Store
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Verify JDK version and make sure it's visible
      - name: Verify Java version
        run: |
          echo "JAVA_HOME=$JAVA_HOME"
          echo "PATH=$PATH"
          echo "Java version:"
          java -version
          echo "Javac version:"
          javac -version
          echo "All java installations:"
          which java || echo "No java found"
          ls -la $JAVA_HOME/bin/ || echo "No JAVA_HOME/bin directory"

      # Setup Android SDK
      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      # Grant execute permissions for Gradle wrapper
      - name: Grant execute permission to Gradle wrapper
        run: chmod +x ./android/gradlew

      # Fix Java version - simplified approach
      - name: Prepare Java 17 environment
        run: |
          echo "=== Setting up Java 17 compatibility ==="
          
          # Create gradle.properties with Java 17 settings
          cat > android/gradle.properties << EOF
          # Java 17 settings
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 --add-opens java.base/java.io=ALL-UNNAMED
          org.gradle.java.home=${JAVA_HOME}
          android.useAndroidX=true
          kotlin.jvm.target.validation.mode=warning
          # Debug settings
          org.gradle.logging.level=debug
          EOF
          
          echo "=== Java setup complete ==="

      # Build Release APK instead of Debug
      - name: Build Release APK
        id: build_apk
        run: |
          cd android
          
          # Create direct signing config to avoid issues
          echo "// Direct signing configuration" > app/signing.gradle
          cat >> app/signing.gradle << EOF
          android {
              signingConfigs {
                  release {
                      storeFile file("release.keystore")
                      storePassword "${KEY_STORE_PASSWORD}"
                      keyAlias "${KEY_ALIAS}"
                      keyPassword "${KEY_PASSWORD}"
                  }
              }
              
              buildTypes {
                  release {
                      signingConfig signingConfigs.release
                  }
              }
          }
          EOF
          
          # Add the signing config to app's build.gradle
          echo "apply from: 'signing.gradle'" >> app/build.gradle
          
          # Very verbose build with retries
          echo "==== BUILDING APK (ATTEMPT 1) ===="
          ./gradlew --no-daemon clean assembleRelease --info || (
            echo "First build attempt failed, retrying..."
            echo "==== BUILDING APK (ATTEMPT 2) ===="
            ./gradlew --no-daemon clean assembleRelease --info
          )
          
          # Check for APKs
          echo "==== CHECKING FOR APK FILES ===="
          find . -name "*.apk" -type f | sort
          
          # Copy APK to the expected location for signing
          mkdir -p app/build/outputs/apk/release
          RELEASE_APK=$(find . -name "*release*.apk" -type f | head -n 1)
          if [ -n "$RELEASE_APK" ]; then
            echo "Found release APK: $RELEASE_APK"
            cp "$RELEASE_APK" app/build/outputs/apk/release/app-release-unsigned.apk
            echo "Copied to app/build/outputs/apk/release/app-release-unsigned.apk"
            ls -la app/build/outputs/apk/release/
          else
            echo "No APK found, build failed!"
            exit 1
          fi
        env:
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          KEY_STORE_PASSWORD: ${{ secrets.KEY_STORE_PASSWORD }}

      # Skip the locate_apk step as it's now handled in the build step
      
      # Sign APK directly with apksigner
      - name: Sign APK with apksigner
        id: sign_app
        run: |
          echo "==== SIGNING APK DIRECTLY ===="
          # Ensure the APK exists
          if [ ! -f "android/app/build/outputs/apk/release/app-release-unsigned.apk" ]; then
            echo "ERROR: APK file not found at expected location"
            find android -name "*.apk" -type f
            exit 1
          fi
          
          # Create output directory
          mkdir -p android/app/build/outputs/apk/release/signed
          
          # Use Android SDK apksigner directly
          APKSIGNER="$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner"
          
          # Sign the APK
          $APKSIGNER sign --ks release.keystore \
            --ks-key-alias "${{ secrets.KEY_ALIAS }}" \
            --ks-pass pass:"${{ secrets.KEY_STORE_PASSWORD }}" \
            --key-pass pass:"${{ secrets.KEY_PASSWORD }}" \
            --out android/app/build/outputs/apk/release/signed/app-release-signed.apk \
            android/app/build/outputs/apk/release/app-release-unsigned.apk
          
          # Verify the signing
          $APKSIGNER verify --verbose android/app/build/outputs/apk/release/signed/app-release-signed.apk
          
          # Set output variable
          echo "signedReleaseFile=android/app/build/outputs/apk/release/signed/app-release-signed.apk" >> $GITHUB_OUTPUT
          
          echo "==== APK SIGNED SUCCESSFULLY ===="

      # Create a Release
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          release_name: 'Release ${{ env.RELEASE_TAG }}'
          draft: false
          prerelease: true

      # Upload Signed APK to Release
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.sign_app.outputs.signedReleaseFile }}
          asset_name: app-release-signed.apk
          asset_content_type: application/vnd.android.package-archive

      # Setup for Zap.Store publishing
      - name: Setup Dart SDK
        uses: dart-lang/setup-dart@v1.6.5
      
      - name: Install Apktool
        run: |
          wget "https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/linux/apktool"
          wget "https://github.com/iBotPeaches/Apktool/releases/download/v2.10.0/apktool_2.10.0.jar"
          mv apktool_2.10.0.jar apktool.jar
          sudo cp apktool /usr/local/bin
          sudo cp apktool.jar /usr/local/bin
          sudo chmod +x /usr/local/bin/apktool
          sudo chmod +x /usr/local/bin/apktool.jar
      
      - name: Get Zap.Store CLI
        run: |
          mkdir -p /home/runner/.zapstore
          git clone https://github.com/zapstore/zapstore-cli.git
          cd zapstore-cli
          git fetch --tags
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/zapstore/zapstore-cli/releases/latest)
          TAG_NAME=$(echo $LATEST_RELEASE | jq -r .tag_name)
          git checkout $TAG_NAME
          dart pub get
          dart compile exe lib/main.dart -o build
      
      # Publish to Zap.Store
      - name: Publish to Zap.Store
        env:
          NSEC: ${{ secrets.NSEC }}
        run: |
          echo "==== PUBLISHING TO ZAP.STORE ===="
          
          # Ensure the file exists
          if [ ! -f "${{ steps.sign_app.outputs.signedReleaseFile }}" ]; then
            echo "ERROR: Signed APK file not found!"
            exit 1
          fi
          
          # Print file info
          ls -la ${{ steps.sign_app.outputs.signedReleaseFile }}
          
          # Verify the file is valid
          file ${{ steps.sign_app.outputs.signedReleaseFile }}
          
          # Copy to a simple path to avoid issues
          cp ${{ steps.sign_app.outputs.signedReleaseFile }} ./runstr-app.apk
          
          # Show zapstore-cli help
          cd zapstore-cli && ./build --help
          
          # Explicitly use the copied APK with the absolute path
          APK_PATH="$GITHUB_WORKSPACE/runstr-app.apk"
          echo "Using APK: $APK_PATH"
          
          # Run the publish command with explicit paths
          ./build publish "RUNSTR" --apk-path="$APK_PATH" --apksigner-path="$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner"
          
          echo "==== ZAP.STORE PUBLISHING COMPLETE ===="