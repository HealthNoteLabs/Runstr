# .github/workflows/release-and-publish.yml
name: Release RUNSTR and Publish to Zapstore

on:
  push:
    branches:
      # Release from main branch (adjust as needed)
      - main
      # Prereleases/builds from updates1 (adjust branch name and prerelease config in .releaserc if needed)
      - updates1
      # Explicitly add the current working branch for testing visibility
      - updates1-release-prep
  # Enable manual trigger for the Zapstore publish step confirmation
  workflow_dispatch:
    inputs:
      force_version:
        description: 'Force specific version (leave empty to use semantic-release)'
        required: false
        default: ''
      skip_semantic_release:
        description: 'Skip semantic-release process and use forced version'
        type: boolean
        required: false
        default: false

jobs:
  # ================= Release & Build Job =================
  release_and_build:
    runs-on: ubuntu-latest
    outputs:
      # Output whether a release was created by semantic-release
      released: ${{ steps.semantic_release.outputs.released || 'false' }}
      # Output the final version determined (semantic or package.json)
      build_version: ${{ steps.determine_build_version.outputs.build_version }}
      # Output the final APK path for artifact upload/download
      apk_path: ${{ steps.prepare_artifact.outputs.apk_path }}

    permissions:
      contents: write # Allow semantic-release to push commits/tags

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for semantic-release
          # Persist credentials for semantic-release to push
          persist-credentials: true

      # --- Environment Setup ---
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Use your project's Node.js version
          cache: 'npm'

      # --- Dependencies ---
      # Assumes semantic-release and plugins are in devDependencies
      - name: Install Node Dependencies
        run: npm install

      # --- Semantic Release ---
      # This step determines the version, generates changelog, updates package.json, commits, and tags
      - name: Run Semantic Release
        id: semantic_release
        if: ${{ github.event.inputs.skip_semantic_release != 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Use the default GitHub token
          # Add any other env vars needed by semantic-release plugins if necessary
        run: |
          echo "Running semantic-release..."
          # Run semantic-release. It will analyze commits, update package.json, changelog, commit, and tag if needed.
          # Capture output to check if a release happened and get the version.
          # Use '|| true' to prevent workflow failure if no release is needed.
          npx semantic-release --debug || true

          # Check if a release was published by looking for a new tag
          LATEST_TAG=$(git describe --tags --abbrev=0 || echo "none")
          echo "Latest tag found: $LATEST_TAG"

          # Check if package.json was updated (another indicator)
          # This might be fragile if other changes happen concurrently
          if git status --porcelain | grep -q "package.json"; then
             echo "package.json was modified, likely by semantic-release."
             # This isn't a foolproof check for release success, tag check is better
          fi

          # More reliable check: see if the latest tag matches what semantic-release *would* output
          # This requires more complex output parsing from semantic-release, sticking to tag existence for now.

          if [[ "$LATEST_TAG" != "none" ]]; then
            # Check if the latest tag points to the current commit HEAD
            # This confirms semantic-release just created it on this run
            if git rev-parse HEAD | grep -q "$(git rev-list -n 1 $LATEST_TAG)"; then
               echo "‚úÖ New release tag $LATEST_TAG created by semantic-release."
               echo "released=true" >> $GITHUB_OUTPUT
               echo "new_version=${LATEST_TAG#v}" >> $GITHUB_OUTPUT # Store version without 'v' prefix
            else
               echo "‚ÑπÔ∏è Latest tag $LATEST_TAG exists but doesn't point to HEAD. Assuming no new release on this run."
               echo "released=false" >> $GITHUB_OUTPUT
               echo "new_version=unknown" >> $GITHUB_OUTPUT # Set explicitly
            fi
          else
             echo "‚ÑπÔ∏è No tags found or semantic-release determined no release needed."
             echo "released=false" >> $GITHUB_OUTPUT
             echo "new_version=unknown" >> $GITHUB_OUTPUT # Set explicitly
          fi

      # --- Manual Version Creation ---
      - name: Create Manual Release Tag
        id: manual_release
        if: ${{ github.event.inputs.skip_semantic_release == 'true' && github.event.inputs.force_version != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FORCED_VERSION="${{ github.event.inputs.force_version }}"
          echo "Using manually specified version: $FORCED_VERSION"
          
          # Update package.json version
          npm version $FORCED_VERSION --no-git-tag-version
          
          # Create a simple CHANGELOG entry for manual version
          echo "# Release v$FORCED_VERSION" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "Manual release created on $(date)" >> CHANGELOG.md
          
          # Commit the changes
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json CHANGELOG.md
          git commit -m "chore(release): $FORCED_VERSION [skip ci]"
          
          # Create and push the tag
          git tag -a "v$FORCED_VERSION" -m "Release v$FORCED_VERSION"
          git push --follow-tags
          
          echo "released=true" >> $GITHUB_OUTPUT
          echo "new_version=$FORCED_VERSION" >> $GITHUB_OUTPUT

      # --- Read Package Version (Fallback/Info) ---
      # Read the version from package.json (might have been updated by semantic-release)
      - name: Read version from package.json
        id: read_package_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "Version from package.json: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # --- Build Web Assets ---
      # Build the web assets BEFORE syncing with Capacitor
      - name: Build Web App
        run: npm run build

      # --- Capacitor Sync ---
      # Sync web assets AFTER potential package.json version update and AFTER web build
      - name: Sync Capacitor Android Project
        run: npx cap sync android

      # --- Signing Keystore Setup ---
      - name: Configure Keystore from Secret
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        run: |
          KEYSTORE_DIR=$GITHUB_WORKSPACE/android/app
          KEYSTORE_FILE=$KEYSTORE_DIR/runstr-release-key.keystore
          mkdir -p $KEYSTORE_DIR
          echo "Decoding keystore to $KEYSTORE_FILE"
          echo "$KEYSTORE_BASE64" | base64 --decode > "$KEYSTORE_FILE"
          test -s "$KEYSTORE_FILE" || { echo "‚ùå Keystore file missing or empty after decode"; exit 1; }
          echo "Keystore configured."

      # --- Determine Final Version for Build ---
      # Use semantic-release version if available, otherwise use package.json version
      - name: Determine Build Version
        id: determine_build_version
        run: |
          SEMANTIC_VERSION="${{ steps.semantic_release.outputs.new_version }}"
          PACKAGE_VERSION="${{ steps.read_package_version.outputs.version }}"
          BUILD_VERSION=""

          if [[ "${{ steps.semantic_release.outputs.released }}" == "true" && "$SEMANTIC_VERSION" != "unknown" ]]; then
             echo "Using version from semantic-release: $SEMANTIC_VERSION"
             BUILD_VERSION="$SEMANTIC_VERSION"
          elif [[ -n "$PACKAGE_VERSION" ]]; then
             echo "Using version from package.json: $PACKAGE_VERSION"
             BUILD_VERSION="$PACKAGE_VERSION"
          else
             FALLBACK_VERSION="0.0.0-sha-${GITHUB_SHA::7}"
             echo "Warning: Could not determine version reliably. Using fallback: $FALLBACK_VERSION"
             BUILD_VERSION="$FALLBACK_VERSION"
          fi
          echo "Final build version: $BUILD_VERSION"
          echo "build_version=$BUILD_VERSION" >> $GITHUB_OUTPUT

      # --- Build ---
      - name: Build Release APK
        env:
          SIGNING_KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          SIGNING_KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          SIGNING_STORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          cd android
          BUILD_VERSION=${{ steps.determine_build_version.outputs.build_version }}
          echo "Building Release APK version $BUILD_VERSION..."
          # Pass signing config via command line properties
          ./gradlew assembleRelease \
            -Pandroid.injected.signing.store.file=$(realpath ./app/runstr-release-key.keystore) \
            -Pandroid.injected.signing.store.password="$SIGNING_STORE_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$SIGNING_KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$SIGNING_KEY_PASSWORD" \
            -PappVersionName=$BUILD_VERSION # Pass final version to build
          cd ..

      # --- Prepare Artifact ---
      - name: Prepare release directory and Rename APK
        id: prepare_artifact
        run: |
          mkdir -p ./release
          VERSION=${{ steps.determine_build_version.outputs.build_version }}
          APK_ORIGINAL="android/app/build/outputs/apk/release/app-release.apk"
          APK_RENAMED="./release/runstr-${VERSION}.apk" # Consistent naming

          if [[ ! -f "$APK_ORIGINAL" ]]; then
            echo "‚ùå Built APK not found at $APK_ORIGINAL"
            exit 1
          fi

          echo "Moving $APK_ORIGINAL to $APK_RENAMED"
          mv "$APK_ORIGINAL" "$APK_RENAMED"
          echo "‚úÖ APK prepared: $APK_RENAMED"
          echo "apk_path=$APK_RENAMED" >> $GITHUB_OUTPUT # Output path

      - name: Validate APK file
        run: |
          APK_PATH="${{ steps.prepare_artifact.outputs.apk_path }}"
          echo "Validating $APK_PATH"
          test -f "$APK_PATH" || { echo "‚ùå APK file not found: $APK_PATH"; exit 1; }
          SIZE=$(stat -c%s "$APK_PATH")
          echo "APK size: $SIZE bytes"
          if [ "$SIZE" -lt 100000 ]; then # Check minimum reasonable size
            echo "‚ö†Ô∏è Warning: APK might be too small ($SIZE bytes)"
          fi
          unzip -l "$APK_PATH" | grep -q AndroidManifest.xml || {
            echo "‚ùå APK appears invalid (no AndroidManifest.xml found)"
            exit 1
          }
          echo "‚úÖ Basic APK structure checked."

      # --- Create GitHub Release ---
      - name: Create GitHub Release and Upload APK
        # Only run if semantic-release created a new version
        if: steps.semantic_release.outputs.released == 'true'
        uses: softprops/action-gh-release@v1
        with:
          # Tag name should match the tag created by semantic-release (usually with 'v' prefix)
          tag_name: v${{ steps.determine_build_version.outputs.build_version }}
          # Name the release using the version
          name: Release v${{ steps.determine_build_version.outputs.build_version }}
          # Use the generated CHANGELOG.md as the release body
          # Ensure semantic-release config includes @semantic-release/changelog plugin
          body_path: CHANGELOG.md
          # Path to the APK file to upload, from the prepare_artifact step
          files: ${{ steps.prepare_artifact.outputs.apk_path }}
          # Publish the release (not a draft)
          draft: false
          # Mark as a non-prerelease (adjust if needed for prerelease branches)
          prerelease: false
        env:
          # Use the default GITHUB_TOKEN for release creation
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: runstr-apk-${{ steps.determine_build_version.outputs.build_version }}
          path: ${{ steps.prepare_artifact.outputs.apk_path }}
          retention-days: 7

      - name: Upload CHANGELOG artifact
        # Always upload CHANGELOG.md if it exists and the job reaches this point
        uses: actions/upload-artifact@v4
        with:
           name: changelog-${{ steps.determine_build_version.outputs.build_version }}
           path: CHANGELOG.md
           if-no-files-found: warn # Don't fail if CHANGELOG.md is somehow missing
           retention-days: 7

      - name: Clean up Keystore
        if: ${{ always() }} # Always run this step
        run: |
          echo "Removing keystore file..."
          rm -f $GITHUB_WORKSPACE/android/app/runstr-release-key.keystore

  # ================= Zapstore Publish Job =================
  publish_zapstore:
    needs: release_and_build # Depends on the release and build job
    runs-on: ubuntu-latest
    # Add environment for manual approval

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download APK artifact
        uses: actions/download-artifact@v4
        with:
          # Use the consistent build_version output from the previous job
          name: runstr-apk-${{ needs.release_and_build.outputs.build_version }}
          path: ./release # Download into a release directory

      - name: List downloaded files
        run: ls -lR ./release

      # --- Install Zapstore Tools ---
      - name: Install ZapStore CLI and apktool
        run: |
          echo "Installing Zapstore CLI..."
          ZAP_CLI_URL="https://cdn.zapstore.dev/0d684425c4bbd3fdecc58f7bf7fc55366d71b8ded9d68b3bbfcb3fcca1072325"
          curl -L -o zapstore "$ZAP_CLI_URL"
          chmod +x zapstore
          sudo mv zapstore /usr/local/bin/
          zapstore --version || { echo "‚ùå Zapstore CLI install failed."; exit 1; }
          echo "‚úÖ Zapstore CLI installed."

          echo "Installing apktool via apt..."
          sudo apt-get update -y
          sudo apt-get install -y apktool || { echo "‚ùå apktool install via apt failed."; exit 1; }
          echo "‚úÖ apktool installed via apt."

          # Verify apktool installation
          apktool --version || { echo "‚ùå apktool command not found or failed after install."; exit 1; }
          echo "‚úÖ apktool verified."

      - name: Install Android apksigner tool
        run: |
          sudo apt-get update -y && sudo apt-get install -y unzip wget default-jre # JRE needed by apksigner
          echo "Downloading Android Build Tools..."
          # Use a known reliable version, adjust if needed
          BUILD_TOOLS_VERSION="33.0.2"
          wget -q https://dl.google.com/android/repository/build-tools_r${BUILD_TOOLS_VERSION}-linux.zip -O /tmp/build-tools.zip || \
            { echo "‚ùå Failed to download Android Build Tools ${BUILD_TOOLS_VERSION}"; exit 1; }
          unzip -q /tmp/build-tools.zip -d /tmp/build-tools
          APKSIGNER_PATH=$(find /tmp/build-tools -name apksigner -type f | head -n 1)
          if [ -z "$APKSIGNER_PATH" ]; then
             echo "‚ùå apksigner not found in downloaded build tools."
             exit 1
          fi
          echo "‚úÖ apksigner found at: $APKSIGNER_PATH"
          echo "APKSIGNER_PATH=$APKSIGNER_PATH" >> $GITHUB_ENV
          chmod +x "$APKSIGNER_PATH"

      # --- Prepare Zapstore Metadata ---
      - name: Create zapstore.yaml and Basic Release Notes
        run: |
          VERSION=${{ needs.release_and_build.outputs.build_version }}
          # Use the raw GitHub URL for the logo in the main branch - KEEP THIS AS IS FOR NOW, but ideally use local copy
          RUNSTR_ICON_URL="https://raw.githubusercontent.com/TheWildHustle/Nostr-Run-Club/main/runstr-logo.png"
          ICON_FILENAME="runstr_logo.png" # Consistent icon filename
          NOTES_FILENAME="release_notes.md"
          ZAPSTORE_YAML_FILENAME="zapstore.yaml" # Define filename

          cd ./release # Work inside the release directory

          # Find the actual APK file downloaded into this directory
          ACTUAL_APK_FILE=$(find . -maxdepth 1 -name 'runstr-*.apk' -print -quit)
          if [ -z "$ACTUAL_APK_FILE" ]; then
            echo "‚ùå Downloaded APK file (runstr-*.apk) not found in ./release directory!"
            exit 1
          fi
          # Get just the filename (basename)
          ACTUAL_APK_FILENAME=$(basename "$ACTUAL_APK_FILE")
          echo "Found APK: $ACTUAL_APK_FILENAME"

          # Copy the existing zapstore.yaml from the repository root
          echo "Copying existing zapstore.yaml from workspace root..."
          cp "$GITHUB_WORKSPACE/$ZAPSTORE_YAML_FILENAME" "./$ZAPSTORE_YAML_FILENAME"
          if [ ! -f "./$ZAPSTORE_YAML_FILENAME" ]; then
            echo "Error: Failed to copy $ZAPSTORE_YAML_FILENAME from repository root."
            # Optionally fail the job if the file is essential
            # exit 1
            # Or provide a default minimal one as fallback? For now, just warn/error.
          else
             echo "‚úÖ Copied $ZAPSTORE_YAML_FILENAME."
          fi

          # Create BASIC release notes (REPLACED EXTRACTION LOGIC)
          echo "Creating basic release notes..."
          echo "# Release v$VERSION" > "$NOTES_FILENAME"
          echo "See repository CHANGELOG.md for full details." >> "$NOTES_FILENAME"
          echo "‚úÖ Basic notes created for v$VERSION."

          # Copy the local logo file into the release directory
          echo "Copying local runstr-logo.png to ./release/$ICON_FILENAME"
          # Ensure the source path is correct relative to GITHUB_WORKSPACE
          cp "$GITHUB_WORKSPACE/runstr-logo.png" "./$ICON_FILENAME" 
          if [ ! -f "./$ICON_FILENAME" ]; then
            echo "Error: Failed to copy runstr-logo.png to release directory."
            exit 1
          fi

          # Set the actual discovered filename for the publish step
          echo "APK_FILENAME=$ACTUAL_APK_FILENAME" >> $GITHUB_ENV
          echo "ICON_FILENAME=$ICON_FILENAME" >> $GITHUB_ENV
          echo "NOTES_FILENAME=$NOTES_FILENAME" >> $GITHUB_ENV
          # We no longer directly use zapstore.yaml filename in the publish command itself
          # but it's good practice to check it exists.

          echo "‚úÖ Metadata (copied), icon, and basic release notes prepared in ./release directory."
          echo "--- Copied Zapstore Config (${ZAPSTORE_YAML_FILENAME}) ---"
          # Optionally cat the copied file for verification
          # cat "${ZAPSTORE_YAML_FILENAME}"
          echo "--- Release Notes (${NOTES_FILENAME}) ---"
          cat "${NOTES_FILENAME}"
          echo "-------------------------------------"
          cd .. # Return to workspace root

      # --- Cleanup Before Publish ---
      - name: Clean up potential intermediate files
        run: |
          echo "Cleaning up ./release directory..."
          rm -f ./release/apktool.yml
          echo "Contents of ./release after cleanup:"
          ls -l ./release
      
      # --- Clean APK Metadata ---
      - name: Clean APK Metadata
        env:
          SIGNING_KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          SIGNING_KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          SIGNING_STORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          cd ./release
          
          echo "Creating backup of original APK..."
          cp "${APK_FILENAME}" "original_${APK_FILENAME}"
          
          echo "Creating temporary directory..."
          mkdir -p temp_meta
          
          # Use a more robust approach to clean the APK
          # Extract the APK to a temporary directory
          mkdir -p clean_apk_contents
          unzip -q "${APK_FILENAME}" -d clean_apk_contents

          # Find and remove ALL YAML files that might contain problematic metadata
          echo "Removing all .yml files from APK..."
          find clean_apk_contents -name "*.yml" -type f -delete
          find clean_apk_contents -name "*.yaml" -type f -delete
          
          # Special handling for apktool.yml which is most often the cause
          rm -f clean_apk_contents/apktool.yml
          rm -f clean_apk_contents/META-INF/apktool.yml
          
          # Remove signature files since we'll need to re-sign anyway
          echo "Removing existing signature files..."
          rm -rf clean_apk_contents/META-INF/*.RSA
          rm -rf clean_apk_contents/META-INF/*.SF
          rm -rf clean_apk_contents/META-INF/*.MF
          
          echo "Creating cleaned unsigned APK..."
          # Create a new, clean APK without any YML files
          cd clean_apk_contents
          zip -r -q "../clean_unsigned_${APK_FILENAME}" ./*
          cd ..
          
          # Check if we need to re-sign
          echo "Verifying if we need to re-sign the APK..."
          # Save the clean unsigned APK for reference
          mv "clean_unsigned_${APK_FILENAME}" "unsigned_${APK_FILENAME}"
          
          if [ -f "../android/app/runstr-release-key.keystore" ]; then
            echo "Keystore found, re-signing the APK..."
            
            # Re-sign the APK using the same key
            "$APKSIGNER_PATH" sign \
              --ks "../android/app/runstr-release-key.keystore" \
              --ks-key-alias "$SIGNING_KEY_ALIAS" \
              --ks-pass "pass:$SIGNING_STORE_PASSWORD" \
              --key-pass "pass:$SIGNING_KEY_PASSWORD" \
              --out "clean_${APK_FILENAME}" \
              "unsigned_${APK_FILENAME}"
              
            if [ $? -eq 0 ]; then
              echo "‚úÖ APK re-signed successfully"
              # Replace the original APK with the cleaned and signed version
              mv "clean_${APK_FILENAME}" "${APK_FILENAME}"
            else
              echo "‚ö†Ô∏è Re-signing failed, using original APK for safety"
              # Keep original APK since signing failed
              cp "original_${APK_FILENAME}" "${APK_FILENAME}"
            fi
          else
            echo "‚ö†Ô∏è Keystore not found, using original APK for safety"
            # Keep original APK since we can't re-sign
            cp "original_${APK_FILENAME}" "${APK_FILENAME}"
          fi
          
          # Clean up
          rm -rf temp_meta clean_apk_contents
          
          echo "‚úÖ APK metadata cleaning process completed"
          cd ..
      
      # --- Verify Cleaned APK ---
      - name: Verify Cleaned APK
        run: |
          cd ./release
          
          echo "Verifying APK is free from problematic metadata..."
          
          # Create a temporary directory for verification
          mkdir -p verify_apk
          
          # Try to extract ANY yml files to see if we missed any
          unzip -q "${APK_FILENAME}" "*.yml" -d verify_apk 2>/dev/null || true
          unzip -q "${APK_FILENAME}" "META-INF/*.yml" -d verify_apk 2>/dev/null || true
          
          # Check if any YML files were found
          if [ -n "$(find verify_apk -type f -name "*.yml" 2>/dev/null)" ]; then
            echo "‚ö†Ô∏è Warning: Some YAML files still present in APK after cleaning!"
            # Check specifically for the problematic tag
            if grep -q "!!brut.androlib.meta.MetaInfo" verify_apk/*/*.yml 2>/dev/null || grep -q "!!brut.androlib.meta.MetaInfo" verify_apk/*.yml 2>/dev/null; then
              echo "‚ùå ERROR: Problematic '!!brut.androlib.meta.MetaInfo' tag still found in APK after cleaning!"
              echo "Attempting emergency deeper cleaning..."
              
              # More aggressive cleaning attempt as a last resort
              mkdir -p emergency_clean
              unzip -q "${APK_FILENAME}" -d emergency_clean
              find emergency_clean -name "*.yml" -o -name "*.yaml" -type f -delete
              
              # Create a fresh APK without ANY yml files
              cd emergency_clean
              zip -r -q "../emergency_${APK_FILENAME}" ./*
              cd ..
              
              # Replace the APK with this emergency cleaned version
              mv "emergency_${APK_FILENAME}" "${APK_FILENAME}"
              rm -rf emergency_clean
              
              echo "Emergency cleaning completed. Proceeding with caution."
            else
              echo "YML files found but do not contain problematic tags. Proceeding with caution."
            fi
          else
            echo "‚úÖ Verification passed - no problematic metadata found in APK"
          fi
          
          # Final check of APK validity
          if ! unzip -l "${APK_FILENAME}" | grep -q AndroidManifest.xml; then
            echo "‚ùå Error: APK appears invalid after cleaning (no AndroidManifest.xml found)"
            # Restore the original APK as a fallback
            cp "original_${APK_FILENAME}" "${APK_FILENAME}"
            echo "Restored original APK due to validation failure."
          fi
          
          # Clean up
          rm -rf verify_apk
          cd ..
          
      # --- Publish ---
      - name: Publish to Zapstore
        env:
          NSEC: ${{ secrets.NSEC }}
          APKSIGNER_PATH: ${{ env.APKSIGNER_PATH }}
          VERSION: ${{ needs.release_and_build.outputs.build_version }}
        run: |
          cd ./release # Navigate into the directory with assets

          echo "Publishing v${VERSION} to Zapstore using apksigner at $APKSIGNER_PATH..."
          echo "Icon file: ${ICON_FILENAME}"
          echo "APK file: ${APK_FILENAME}"
          echo "Notes file: ${NOTES_FILENAME}"

          # Check files exist before publishing
          test -f "${ICON_FILENAME}" || { echo "‚ùå Icon file '${ICON_FILENAME}' not found!"; exit 1; }
          test -f "${APK_FILENAME}" || { echo "‚ùå APK file '${APK_FILENAME}' not found!"; exit 1; }
          test -f "${NOTES_FILENAME}" || { echo "‚ùå Notes file '${NOTES_FILENAME}' not found!"; exit 1; }

          # Verify APK has a signature
          if [ -f "${APK_FILENAME}" ]; then
            echo "Checking APK signature..."
            if unzip -l "${APK_FILENAME}" | grep -q "META-INF/.*\.RSA"; then
              echo "‚úÖ APK appears to be signed (found .RSA files)"
            else
              echo "‚ö†Ô∏è Warning: APK may not be properly signed (no .RSA files found)"
              echo "Publishing may fail due to signature verification"
            fi
          fi

          # Attempt to publish to Zapstore
          echo "Attempting to publish to Zapstore..."
          set +e  # Don't exit on error for this command
          APKSIGNER_PATH="$APKSIGNER_PATH" zapstore publish runstr \
            --daemon-mode \
            --overwrite-app \
            --overwrite-release \
            --icon "${ICON_FILENAME}" \
            -n "${NOTES_FILENAME}" \
            -a "${APK_FILENAME}" \
            -v "${VERSION}"
          RESULT=$?
          set -e  # Re-enable exit on error
          
          # Check if the publish command failed
          if [ $RESULT -ne 0 ]; then
            echo "‚ö†Ô∏è Publish attempt failed with exit code $RESULT"
            
            # Get error output to diagnose the issue
            ERROR_OUTPUT=$(APKSIGNER_PATH="$APKSIGNER_PATH" zapstore publish runstr \
              --daemon-mode \
              --overwrite-app \
              --overwrite-release \
              --icon "${ICON_FILENAME}" \
              -n "${NOTES_FILENAME}" \
              -a "${APK_FILENAME}" \
              -v "${VERSION}" 2>&1)
              
            if echo "$ERROR_OUTPUT" | grep -q "Error on line 1, column 1: Invalid tag for mapping"; then
              echo "üîÑ Detected YAML parsing error. This is a known issue with some APKs."
              echo "The APK may still be valid and the publishing might have succeeded despite the error."
              
              # Check if the file was actually uploaded
              if echo "$ERROR_OUTPUT" | grep -q "Uploaded artifact"; then
                echo "‚úÖ APK was uploaded successfully despite YAML parsing error."
                echo "Please verify in the Zapstore that the app was published correctly."
                exit 0
              else
                echo "‚ùå APK upload failed due to YAML parsing error."
                exit 1
              fi
            elif echo "$ERROR_OUTPUT" | grep -q "ShellException.*apksigner verify"; then
              echo "‚ö†Ô∏è Detected signature verification error."
              
              # Check if the file was actually uploaded
              if echo "$ERROR_OUTPUT" | grep -q "Uploaded artifact"; then
                echo "‚úÖ APK was uploaded successfully but signature verification failed."
                echo "Please verify in the Zapstore that the app was published correctly."
                exit 0
              else
                echo "‚ùå APK failed signature verification before upload."
                exit 1
              fi
            else
              echo "‚ùå Publish failed with an unexpected error:"
              echo "$ERROR_OUTPUT"
              exit $RESULT
            fi
          else
            echo "‚úÖ Successfully published version ${VERSION} to Zapstore!"
          fi

      - name: ‚úÖ Notify success
        if: ${{ success() }}
        run: |
          echo "üéâ RUNSTR v${{ needs.release_and_build.outputs.build_version }} published to Zapstore!"
          echo "üîó https://zapstore.dev/app/runstr"
