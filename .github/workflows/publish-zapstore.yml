# .github/workflows/release-and-publish.yml
name: Release RUNSTR and Publish to Zapstore

on:
  push:
    branches:
      # Release from main branch (adjust as needed)
      - main
      # Prereleases/builds from updates1 (adjust branch name and prerelease config in .releaserc if needed)
      - updates1
      # Explicitly add the current working branch for testing visibility
      - updates1-release-prep
  # Enable manual trigger for the Zapstore publish step confirmation
  workflow_dispatch:
    inputs:
      force_version:
        description: 'Force specific version (leave empty to use semantic-release)'
        required: false
        default: ''
      skip_semantic_release:
        description: 'Skip semantic-release process and use forced version'
        type: boolean
        required: false
        default: false

jobs:
  # ================= Release & Build Job =================
  release_and_build:
    runs-on: ubuntu-latest
    outputs:
      # Output whether a release was created by semantic-release
      released: ${{ steps.semantic_release.outputs.released || 'false' }}
      # Output the final version determined (semantic or package.json)
      build_version: ${{ steps.determine_build_version.outputs.build_version }}
      # Output the final APK path for artifact upload/download
      apk_path: ${{ steps.prepare_artifact.outputs.apk_path }}

    permissions:
      contents: write # Allow semantic-release to push commits/tags

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for semantic-release
          # Persist credentials for semantic-release to push
          persist-credentials: true

      # --- Environment Setup ---
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Use your project's Node.js version
          cache: 'npm'

      # --- Dependencies ---
      # Assumes semantic-release and plugins are in devDependencies
      - name: Install Node Dependencies
        run: npm install
        
      - name: Install apktool for cleaning # Add apktool install here
        run: |
          echo "Installing apktool via apt..."
          sudo apt-get update -y
          sudo apt-get install -y apktool || { echo "‚ùå apktool install via apt failed."; exit 1; }
          echo "‚úÖ apktool installed via apt."
          apktool --version || { echo "‚ùå apktool command not found or failed after install."; exit 1; }

      # --- Semantic Release ---
      # This step determines the version, generates changelog, updates package.json, commits, and tags
      - name: Run Semantic Release
        id: semantic_release
        if: ${{ github.event.inputs.skip_semantic_release != 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Use the default GitHub token
          # Add any other env vars needed by semantic-release plugins if necessary
        run: |
          echo "Running semantic-release..."
          # Run semantic-release. It will analyze commits, update package.json, changelog, commit, and tag if needed.
          # Capture output to check if a release happened and get the version.
          # Use '|| true' to prevent workflow failure if no release is needed.
          npx semantic-release --debug || true

          # Check if a release was published by looking for a new tag
          LATEST_TAG=$(git describe --tags --abbrev=0 || echo "none")
          echo "Latest tag found: $LATEST_TAG"

          # Check if package.json was updated (another indicator)
          # This might be fragile if other changes happen concurrently
          if git status --porcelain | grep -q "package.json"; then
             echo "package.json was modified, likely by semantic-release."
             # This isn't a foolproof check for release success, tag check is better
          fi

          # More reliable check: see if the latest tag matches what semantic-release *would* output
          # This requires more complex output parsing from semantic-release, sticking to tag existence for now.

          if [[ "$LATEST_TAG" != "none" ]]; then
            # Check if the latest tag points to the current commit HEAD
            # This confirms semantic-release just created it on this run
            if git rev-parse HEAD | grep -q "$(git rev-list -n 1 $LATEST_TAG)"; then
               echo "‚úÖ New release tag $LATEST_TAG created by semantic-release."
               echo "released=true" >> $GITHUB_OUTPUT
               echo "new_version=${LATEST_TAG#v}" >> $GITHUB_OUTPUT # Store version without 'v' prefix
            else
               echo "‚ÑπÔ∏è Latest tag $LATEST_TAG exists but doesn't point to HEAD. Assuming no new release on this run."
               echo "released=false" >> $GITHUB_OUTPUT
               echo "new_version=unknown" >> $GITHUB_OUTPUT # Set explicitly
            fi
          else
             echo "‚ÑπÔ∏è No tags found or semantic-release determined no release needed."
             echo "released=false" >> $GITHUB_OUTPUT
             echo "new_version=unknown" >> $GITHUB_OUTPUT # Set explicitly
          fi

      # --- Manual Version Creation ---
      - name: Create Manual Release Tag
        id: manual_release
        if: ${{ github.event.inputs.skip_semantic_release == 'true' && github.event.inputs.force_version != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FORCED_VERSION="${{ github.event.inputs.force_version }}"
          echo "Using manually specified version: $FORCED_VERSION"
          
          # Update package.json version
          npm version $FORCED_VERSION --no-git-tag-version
          
          # Create a simple CHANGELOG entry for manual version
          echo "# Release v$FORCED_VERSION" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "Manual release created on $(date)" >> CHANGELOG.md
          
          # Commit the changes
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json CHANGELOG.md
          git commit -m "chore(release): $FORCED_VERSION [skip ci]"
          
          # Create and push the tag
          git tag -a "v$FORCED_VERSION" -m "Release v$FORCED_VERSION"
          git push --follow-tags
          
          echo "released=true" >> $GITHUB_OUTPUT
          echo "new_version=$FORCED_VERSION" >> $GITHUB_OUTPUT

      # --- Read Package Version (Fallback/Info) ---
      # Read the version from package.json (might have been updated by semantic-release)
      - name: Read version from package.json
        id: read_package_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "Version from package.json: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # --- Build Web Assets ---
      # Build the web assets BEFORE syncing with Capacitor
      - name: Build Web App
        run: npm run build

      # --- Capacitor Sync ---
      # Sync web assets AFTER potential package.json version update and AFTER web build
      - name: Sync Capacitor Android Project
        run: npx cap sync android

      # --- Signing Keystore Setup ---
      - name: Configure Keystore from Secret
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        run: |
          KEYSTORE_DIR=$GITHUB_WORKSPACE/android/app
          KEYSTORE_FILE=$KEYSTORE_DIR/runstr-release-key.keystore
          mkdir -p $KEYSTORE_DIR
          echo "Decoding keystore to $KEYSTORE_FILE"
          echo "$KEYSTORE_BASE64" | base64 --decode > "$KEYSTORE_FILE"
          test -s "$KEYSTORE_FILE" || { echo "‚ùå Keystore file missing or empty after decode"; exit 1; }
          echo "Keystore configured."

      # --- Determine Final Version for Build ---
      # Use semantic-release version if available, otherwise use package.json version
      - name: Determine Build Version
        id: determine_build_version
        run: |
          SEMANTIC_VERSION="${{ steps.semantic_release.outputs.new_version }}"
          PACKAGE_VERSION="${{ steps.read_package_version.outputs.version }}"
          BUILD_VERSION=""

          if [[ "${{ steps.semantic_release.outputs.released }}" == "true" && "$SEMANTIC_VERSION" != "unknown" ]]; then
             echo "Using version from semantic-release: $SEMANTIC_VERSION"
             BUILD_VERSION="$SEMANTIC_VERSION"
          elif [[ -n "$PACKAGE_VERSION" ]]; then
             echo "Using version from package.json: $PACKAGE_VERSION"
             BUILD_VERSION="$PACKAGE_VERSION"
          else
             FALLBACK_VERSION="0.0.0-sha-${GITHUB_SHA::7}"
             echo "Warning: Could not determine version reliably. Using fallback: $FALLBACK_VERSION"
             BUILD_VERSION="$FALLBACK_VERSION"
          fi
          echo "Final build version: $BUILD_VERSION"
          echo "build_version=$BUILD_VERSION" >> $GITHUB_OUTPUT

      # --- Build ---
      # Changed to packageRelease to build unsigned APK first
      - name: Build Unsigned Release APK Package
        # Add signing properties back - packageRelease needs them defined even if not used for signing here
        env:
          SIGNING_KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          SIGNING_KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          SIGNING_STORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          cd android
          BUILD_VERSION=${{ steps.determine_build_version.outputs.build_version }}
          echo "Building Unsigned Release APK package version $BUILD_VERSION..."
          # Only package, don't assemble/sign yet
          # Remove signing config props, as signingConfig is removed from build.gradle
          ./gradlew packageRelease \
            -PappVersionName=$BUILD_VERSION # Just pass version name
          echo "Unsigned APK location (expected): android/app/build/outputs/apk/release/app-release-unsigned.apk"
          cd ..

      # --- DEBUG: List build output directory ---
      - name: List APK Output Directory
        run: |
          echo "Listing contents of android/app/build/outputs/apk/release/"
          # Use find to be more robust, list details, ignore errors if dir doesn't exist yet
          find android/app/build/outputs/apk/release/ -maxdepth 1 -ls || echo "Directory android/app/build/outputs/apk/release/ not found or empty."

      # --- Align APK (using original unsigned APK) ---
      - name: Find zipalign
        id: find_zipalign
        run: |
          # Find zipalign in the installed Android SDK build-tools
          # Assuming setup-android action puts build-tools on PATH or typical location
          # Or use the path from the setup-android action if it provides one
          ZIPALIGN_PATH=$(find "$ANDROID_SDK_ROOT/build-tools" -name zipalign -type f | sort -r | head -n 1)
          if [ -z "$ZIPALIGN_PATH" ]; then
            echo "‚ùå zipalign not found in SDK build-tools."
            # Fallback: Try finding it on PATH
            if command -v zipalign &> /dev/null; then
              ZIPALIGN_PATH=$(command -v zipalign)
              echo "Found zipalign on PATH: $ZIPALIGN_PATH"
            else
              echo "‚ùå zipalign also not found on PATH. Cannot proceed."
              exit 1
            fi
          fi
          echo "Using zipalign at: $ZIPALIGN_PATH"
          echo "zipalign_path=$ZIPALIGN_PATH" >> $GITHUB_OUTPUT

      - name: Align APK
        id: align_apk
        run: |
          # Use the original unsigned APK path directly
          UNSIGNED_APK="android/app/build/outputs/apk/release/app-release-unsigned.apk"
          # Define output path for the aligned APK
          ALIGNED_APK_PATH="android/app/build/outputs/apk/release/app-release-unsigned-aligned.apk" # Consistent naming
          ZIPALIGN_CMD="${{ steps.find_zipalign.outputs.zipalign_path }}"

          if [ ! -f "$UNSIGNED_APK" ]; then
            echo "‚ùå Original unsigned APK not found: $UNSIGNED_APK"
            exit 1
          fi

          echo "Aligning $UNSIGNED_APK to $ALIGNED_APK_PATH"
          "$ZIPALIGN_CMD" -v 4 "$UNSIGNED_APK" "$ALIGNED_APK_PATH"

          if [ ! -f "$ALIGNED_APK_PATH" ]; then
            echo "‚ùå Failed to create aligned APK at $ALIGNED_APK_PATH"
            exit 1
          fi
          echo "‚úÖ APK aligned: $ALIGNED_APK_PATH"
          echo "aligned_apk_path=$ALIGNED_APK_PATH" >> $GITHUB_OUTPUT

      # --- Sign APK
      - name: Sign APK
        id: sign_apk
        run: |
          # Extract version from build.gradle
          VERSION=$(grep versionName ../../android/app/build.gradle | sed 's/versionName "\(.*\)"/\1/')
          echo "Extracted version: $VERSION"

          # Define paths
          KEYSTORE_PATH="$GITHUB_WORKSPACE/my-release-key.keystore"
          SIGNED_APK_PATH="./release/app-release.apk" # Use a fixed name initially
          FINAL_APK_PATH="./release/runstr-${VERSION}.apk"

          # Check if keystore file exists
          if [ ! -f "$KEYSTORE_PATH" ]; then
            echo "Keystore file not found at $KEYSTORE_PATH"
            exit 1
          fi

          # Print debug info
          echo "Signing APK: android/app/build/outputs/apk/release/app-release-unsigned.apk"
          echo "Using Keystore: $KEYSTORE_PATH"
          echo "Output Signed APK: $SIGNED_APK_PATH"

          # Use apksigner for signing
          "$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner" sign \
            --ks "$KEYSTORE_PATH" \
            --ks-key-alias "$KEY_ALIAS" \
            --ks-pass pass:"$KEYSTORE_PASSWORD" \
            --key-pass pass:"$KEY_PASSWORD" \
            --v1-signing-enabled true \
            --v2-signing-enabled true \
            --out "$SIGNED_APK_PATH" \
            android/app/build/outputs/apk/release/app-release-unsigned.apk

          # Verify the signature
          "$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner" verify "$SIGNED_APK_PATH"
          echo "‚úÖ APK signed and verified successfully."

          # Rename the signed APK to include the version
          mv "$SIGNED_APK_PATH" "$FINAL_APK_PATH"
          echo "Renamed signed APK to $FINAL_APK_PATH"

          # Set output for artifact name
          echo "apk_name=runstr-${VERSION}.apk" >> $GITHUB_OUTPUT
          echo "apk_path=$FINAL_APK_PATH" >> $GITHUB_OUTPUT

      - name: Validate APK Metadata
        id: validate_metadata
        run: |
          APK_PATH="${{ steps.sign_apk.outputs.apk_path }}"
          echo "Validating metadata for $APK_PATH"
          PACKAGE=$(aapt2 dump badging "$APK_PATH" | grep "package:" | awk '{print $2}' | cut -d"'" -f2)
          VERSION_NAME=$(aapt2 dump badging "$APK_PATH" | grep "versionName=" | cut -d"'" -f2)
          VERSION_CODE=$(aapt2 dump badging "$APK_PATH" | grep "versionCode=" | cut -d"'" -f2)

          if [ -z "$PACKAGE" ] || [ -z "$VERSION_NAME" ] || [ -z "$VERSION_CODE" ]; then
            echo "‚ùå APK missing required metadata (package/versionName/versionCode)"
            aapt2 dump badging "$APK_PATH" # Print details for debugging
            exit 1
          else
            echo "‚úÖ APK Metadata:"
            echo "   Package: $PACKAGE"
            echo "   Version Name: $VERSION_NAME"
            echo "   Version Code: $VERSION_CODE"
          fi
          # Optionally, pass these to outputs if needed later
          echo "package_name=$PACKAGE" >> $GITHUB_OUTPUT
          echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

      - name: Verify Artifact Before Upload
        id: verify_before_upload
        run: |
          APK_PATH="${{ steps.sign_apk.outputs.apk_path }}"
          echo "Calculating SHA256 for $APK_PATH before upload..."
          # Calculate and output the hash (first field of sha256sum output)
          HASH=$(sha256sum "$APK_PATH" | awk '{ print $1 }')
          echo "SHA256: $HASH"
          echo "apk_hash=$HASH" >> $GITHUB_OUTPUT

      # --- Prepare Artifact ---
      # Now uses the final signed APK from the previous step
      - name: Prepare release directory and Rename APK
        id: prepare_artifact
        run: |
          mkdir -p ./release
          VERSION=${{ steps.determine_build_version.outputs.build_version }}
          # Use the output from the sign_apk step
          APK_ORIGINAL="${{ steps.sign_apk.outputs.apk_path }}"
          APK_RENAMED="./release/runstr-${VERSION}.apk" # Consistent naming

          if [[ ! -f "$APK_ORIGINAL" ]]; then
            echo "‚ùå Final signed APK not found at $APK_ORIGINAL"
            exit 1
          fi

          echo "Moving $APK_ORIGINAL to $APK_RENAMED"
          mv "$APK_ORIGINAL" "$APK_RENAMED"
          # Clean up intermediate files (optional, runner cleans anyway)
          rm -f ${{ steps.align_apk.outputs.aligned_apk_path }}
          echo "‚úÖ Final APK prepared: $APK_RENAMED"
          echo "apk_path=$APK_RENAMED" >> $GITHUB_OUTPUT # Output path

      - name: Validate APK file
        run: |
          APK_PATH="${{ steps.prepare_artifact.outputs.apk_path }}"
          echo "Validating $APK_PATH"
          test -f "$APK_PATH" || { echo "‚ùå APK file not found: $APK_PATH"; exit 1; }
          SIZE=$(stat -c%s "$APK_PATH")
          echo "APK size: $SIZE bytes"
          if [ "$SIZE" -lt 100000 ]; then # Check minimum reasonable size
            echo "‚ö†Ô∏è Warning: APK might be too small ($SIZE bytes)"
          fi
          unzip -l "$APK_PATH" | grep -q AndroidManifest.xml || {
            echo "‚ùå APK appears invalid (no AndroidManifest.xml found)"
            exit 1
          }
          echo "‚úÖ Basic APK structure checked."

      # --- Create GitHub Release ---
      - name: Create GitHub Release and Upload APK
        # Only run if semantic-release created a new version
        if: steps.semantic_release.outputs.released == 'true'
        uses: softprops/action-gh-release@v1
        with:
          # Tag name should match the tag created by semantic-release (usually with 'v' prefix)
          tag_name: v${{ steps.determine_build_version.outputs.build_version }}
          # Name the release using the version
          name: Release v${{ steps.determine_build_version.outputs.build_version }}
          # Use the generated CHANGELOG.md as the release body
          # Ensure semantic-release config includes @semantic-release/changelog plugin
          body_path: CHANGELOG.md
          # Path to the APK file to upload, from the prepare_artifact step
          files: ${{ steps.prepare_artifact.outputs.apk_path }}
          # Publish the release (not a draft)
          draft: false
          # Mark as a non-prerelease (adjust if needed for prerelease branches)
          prerelease: false
        env:
          # Use the default GITHUB_TOKEN for release creation
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: runstr-apk-${{ steps.determine_build_version.outputs.build_version }}
          path: ${{ steps.prepare_artifact.outputs.apk_path }}
          retention-days: 7

      - name: Upload CHANGELOG artifact
        # Always upload CHANGELOG.md if it exists and the job reaches this point
        uses: actions/upload-artifact@v4
        with:
           name: changelog-${{ steps.determine_build_version.outputs.build_version }}
           path: CHANGELOG.md
           if-no-files-found: warn # Don't fail if CHANGELOG.md is somehow missing
           retention-days: 7

      - name: Clean up Keystore
        if: ${{ always() }} # Always run this step
        run: |
          echo "Removing keystore file..."
          rm -f $GITHUB_WORKSPACE/android/app/runstr-release-key.keystore

  # ================= Zapstore Publish Job =================
  publish_zapstore:
    needs: release_and_build # Depends on the release and build job
    runs-on: ubuntu-latest
    # Add environment for manual approval

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download APK artifact
        uses: actions/download-artifact@v4
        with:
          # Use the consistent build_version output from the previous job
          name: runstr-apk-${{ needs.release_and_build.outputs.build_version }}
          path: ./release # Download into a release directory

      - name: Verify Artifact After Download
        id: verify_after_download
        run: |
          cd ./release
          # Find the downloaded APK
          APK_FILE=$(find . -maxdepth 1 -name 'runstr-*.apk' -print -quit)
          if [ -z "$APK_FILE" ]; then
            echo "‚ùå Downloaded APK file (runstr-*.apk) not found in ./release directory!"
            exit 1
          fi
          ACTUAL_APK_FILENAME=$(basename "$APK_FILE")
          echo "Verifying SHA256 for $ACTUAL_APK_FILENAME..."
          # Calculate hash of the downloaded file
          DOWNLOADED_HASH=$(sha256sum "$ACTUAL_APK_FILENAME" | awk '{ print $1 }')
          # Get the expected hash from the build job's output
          EXPECTED_HASH="${{ needs.release_and_build.outputs.apk_hash }}"

          echo "  Expected SHA256: $EXPECTED_HASH"
          echo "  Downloaded SHA256: $DOWNLOADED_HASH"

          if [[ "$DOWNLOADED_HASH" == "$EXPECTED_HASH" ]]; then
            echo "‚úÖ SHA256 Hashes match!"
          else
            echo "‚ùå SHA256 Hashes DO NOT match!"
            exit 1
          fi
          # Pass the verified filename for subsequent steps
          echo "APK_FILENAME=$ACTUAL_APK_FILENAME" >> $GITHUB_ENV
          cd ..

      - name: List downloaded files
        run: ls -lR ./release

      # --- Install Zapstore Tools ---
      - name: Install ZapStore CLI and apktool # Keep one valid version of this step
      - name: Install ZapStore CLI and apktool # Keep one valid version of this step
        run: |
          echo "Installing Zapstore CLI..."
          ZAP_CLI_URL="https://cdn.zapstore.dev/0d684425c4bbd3fdecc58f7bf7fc55366d71b8ded9d68b3bbfcb3fcca1072325"
          curl -L -o zapstore "$ZAP_CLI_URL"
          chmod +x zapstore
          sudo mv zapstore /usr/local/bin/
          zapstore --version || { echo "‚ùå Zapstore CLI install failed."; exit 1; }
          echo "‚úÖ Zapstore CLI installed."

          # Restore apktool installation
          echo "Installing apktool via apt..."
          sudo apt-get update -y
          sudo apt-get install -y apktool || { echo "‚ùå apktool install via apt failed."; exit 1; }
          echo "‚úÖ apktool installed via apt."

          # Restore apktool verification
          apktool --version || { echo "‚ùå apktool command not found or failed after install."; exit 1; }
          echo "‚úÖ apktool verified."

      - name: Install Android apksigner tool
        run: |
          sudo apt-get update -y && sudo apt-get install -y unzip wget default-jre # JRE needed by apksigner
          echo "Downloading Android Build Tools..."
          # Use a known reliable version, adjust if needed
          BUILD_TOOLS_VERSION="33.0.2"
          wget -q https://dl.google.com/android/repository/build-tools_r${BUILD_TOOLS_VERSION}-linux.zip -O /tmp/build-tools.zip || \
            { echo "‚ùå Failed to download Android Build Tools ${BUILD_TOOLS_VERSION}"; exit 1; }
          unzip -q /tmp/build-tools.zip -d /tmp/build-tools
          APKSIGNER_PATH=$(find /tmp/build-tools -name apksigner -type f | head -n 1)
          if [ -z "$APKSIGNER_PATH" ]; then
             echo "‚ùå apksigner not found in downloaded build tools."
             exit 1
          fi
          echo "‚úÖ apksigner found at: $APKSIGNER_PATH"
          echo "APKSIGNER_PATH=$APKSIGNER_PATH" >> $GITHUB_ENV
          chmod +x "$APKSIGNER_PATH"

      # --- Find aapt2 for inspection ---
      - name: Find aapt2 # Keep one valid version of this step
        id: find_aapt2
        run: |
          # Find aapt2 similar to apksigner
          AAPT2_PATH=$(find /tmp/build-tools -name aapt2 -type f | head -n 1)
          if [ -z "$AAPT2_PATH" ]; then
            echo "‚ùå aapt2 not found in downloaded build tools."
            # Attempt to find in SDK ROOT as fallback
            ALT_AAPT2_PATH=$(find "$ANDROID_SDK_ROOT/build-tools" -name aapt2 -type f | sort -r | head -n 1)
            if [ -n "$ALT_AAPT2_PATH" ]; then
               AAPT2_PATH="$ALT_AAPT2_PATH"
               echo "Found aapt2 in SDK build-tools: $AAPT2_PATH"
            else
               echo "‚ùå aapt2 also not found in SDK build-tools. Cannot proceed with badging."
               # Don't exit, allow publish to attempt anyway, but store empty path
               AAPT2_PATH=""
            fi
          fi
          if [ -n "$AAPT2_PATH" ]; then
             echo "Using aapt2 at: $AAPT2_PATH"
             chmod +x "$AAPT2_PATH"
          fi
          echo "aapt2_path=$AAPT2_PATH" >> $GITHUB_OUTPUT

      - name: Install yq for YAML parsing
        run: |
          echo "Installing yq..."
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq && sudo chmod +x /usr/bin/yq
          yq --version || { echo "‚ùå yq install failed."; exit 1; }
          echo "‚úÖ yq installed."

      # --- Prepare Zapstore Metadata ---
      - name: Create zapstore.yaml and Basic Release Notes
        run: |
          VERSION=${{ needs.release_and_build.outputs.build_version }}
          # Use the raw GitHub URL for the logo in the main branch - KEEP THIS AS IS FOR NOW, but ideally use local copy
          RUNSTR_ICON_URL="https://raw.githubusercontent.com/TheWildHustle/Nostr-Run-Club/main/runstr-logo.png"
          ICON_FILENAME="runstr_logo.png" # Consistent icon filename
          NOTES_FILENAME="release_notes.md"
          ZAPSTORE_YAML_FILENAME="zapstore.yaml" # Define filename

          cd ./release # Work inside the release directory

          # Find the actual APK file downloaded into this directory
          ACTUAL_APK_FILE=$(find . -maxdepth 1 -name 'runstr-*.apk' -print -quit)
          if [ -z "$ACTUAL_APK_FILE" ]; then
            echo "‚ùå Downloaded APK file (runstr-*.apk) not found in ./release directory!"
            exit 1
          fi
          # Get just the filename (basename)
          ACTUAL_APK_FILENAME=$(basename "$ACTUAL_APK_FILE")
          echo "Found APK: $ACTUAL_APK_FILENAME"

          # Copy the existing zapstore.yaml from the repository root
          echo "Copying existing zapstore.yaml from workspace root..."
          cp "$GITHUB_WORKSPACE/$ZAPSTORE_YAML_FILENAME" "./$ZAPSTORE_YAML_FILENAME"
          if [ ! -f "./$ZAPSTORE_YAML_FILENAME" ]; then
            echo "Error: Failed to copy $ZAPSTORE_YAML_FILENAME from repository root."
            # Optionally fail the job if the file is essential
            # exit 1
            # Or provide a default minimal one as fallback? For now, just warn/error.
          else
             echo "‚úÖ Copied $ZAPSTORE_YAML_FILENAME."
          fi

          # Create BASIC release notes (REPLACED EXTRACTION LOGIC)
          echo "Creating basic release notes..."
          echo "# Release v$VERSION" > "$NOTES_FILENAME"
          echo "See repository CHANGELOG.md for full details." >> "$NOTES_FILENAME"
          echo "‚úÖ Basic notes created for v$VERSION."

          # Copy the local logo file into the release directory
          echo "Copying local runstr-logo.png to ./release/$ICON_FILENAME"
          # Ensure the source path is correct relative to GITHUB_WORKSPACE
          cp "$GITHUB_WORKSPACE/runstr-logo.png" "./$ICON_FILENAME" 
          if [ ! -f "./$ICON_FILENAME" ]; then
            echo "Error: Failed to copy runstr-logo.png to release directory."
            exit 1
          fi

          # Set the actual discovered filename for the publish step
          echo "APK_FILENAME=$ACTUAL_APK_FILENAME" >> $GITHUB_ENV
          echo "ICON_FILENAME=$ICON_FILENAME" >> $GITHUB_ENV
          echo "NOTES_FILENAME=$NOTES_FILENAME" >> $GITHUB_ENV
          # We no longer directly use zapstore.yaml filename in the publish command itself
          # but it's good practice to check it exists.

          echo "‚úÖ Metadata (copied), icon, and basic release notes prepared in ./release directory."
          echo "--- Copied Zapstore Config (${ZAPSTORE_YAML_FILENAME}) ---"
          # Optionally cat the copied file for verification
          # cat "${ZAPSTORE_YAML_FILENAME}"
          echo "--- Release Notes (${NOTES_FILENAME}) ---"
          cat "${NOTES_FILENAME}"
          echo "-------------------------------------"
          cd .. # Return to workspace root

      - name: Validate zapstore.yaml against APK Metadata
        id: validate_zapstore_config
        env:
           APK_FILENAME: ${{ env.APK_FILENAME }} # Get from verify step
        run: |
          cd ./release
          ZAPSTORE_YAML="./zapstore.yaml"
          APK_FILE="./${APK_FILENAME}" # Use the verified filename

          if [ ! -f "$ZAPSTORE_YAML" ]; then
             echo "‚ö†Ô∏è zapstore.yaml not found in release directory, skipping validation."
             # Decide if this should be a failure or just a warning
             exit 0 # Or exit 1 to fail
          fi
          if [ ! -f "$APK_FILE" ]; then
             echo "‚ùå APK file $APK_FILE not found for validation."
             exit 1
          fi

          echo "Validating $ZAPSTORE_YAML against $APK_FILE..."

          # Extract Package Name from APK using aapt2 (assuming it was found)
          AAPT2_CMD="${{ steps.find_aapt2.outputs.aapt2_path }}"
          APK_PACKAGE_NAME=""
          if [[ -n "$AAPT2_CMD" && -x "$AAPT2_CMD" ]]; then
             APK_PACKAGE_NAME=$("$AAPT2_CMD" dump badging "$APK_FILE" | grep "package:" | awk '{print $2}' | cut -d"'" -f2)
          else
             echo "‚ö†Ô∏è aapt2 not found or executable, cannot extract package name from APK for validation."
             # Allow to proceed but log warning
          fi

          # Extract app_id from zapstore.yaml using yq
          YAML_APP_ID=$(yq e '.app_id' "$ZAPSTORE_YAML")

          echo "  APK Package Name: $APK_PACKAGE_NAME (extracted via aapt2)"
          echo "  zapstore.yaml app_id: $YAML_APP_ID"

          if [[ -n "$APK_PACKAGE_NAME" && "$APK_PACKAGE_NAME" != "$YAML_APP_ID" ]]; then
             echo "‚ùå Mismatch: APK package name ('$APK_PACKAGE_NAME') does not match app_id ('$YAML_APP_ID') in $ZAPSTORE_YAML!"
             # Decide whether to fail the build here
             # exit 1
             echo "‚ö†Ô∏è Continuing despite mismatch..." # Currently warning only
          elif [[ -n "$APK_PACKAGE_NAME" ]]; then
             echo "‚úÖ APK package name matches zapstore.yaml app_id."
          else
             echo "‚ÑπÔ∏è Could not compare app_id as APK package name was not extracted."
          fi

          # Optional: Validate version (needs version from build job)
          # YAML_VERSION=$(yq e '.version' "$ZAPSTORE_YAML")
          # BUILD_VERSION="${{ needs.release_and_build.outputs.build_version }}"
          # echo "  Build Version: $BUILD_VERSION"
          # echo "  zapstore.yaml version: $YAML_VERSION"
          # if [[ "$BUILD_VERSION" != "$YAML_VERSION" ]]; then
          #    echo "‚ùå Mismatch: Build version ('$BUILD_VERSION') does not match version ('$YAML_VERSION') in $ZAPSTORE_YAML!"
          #    # exit 1
          # fi

          cd .. # Return to workspace root

      # --- APKTool Decode for Debugging ---
      - name: Decode APK and Log apktool.yml Before Publish
        id: decode_for_debug
        run: |
          cd ./release
          ACTUAL_APK_FILE=$(find . -maxdepth 1 -name 'runstr-*.apk' -print -quit)
          if [ -z "$ACTUAL_APK_FILE" ]; then
            echo "‚ùå Downloaded APK file (runstr-*.apk) not found in ./release directory for decoding!"
            exit 1
          fi
          ACTUAL_APK_FILENAME=$(basename "$ACTUAL_APK_FILE")
          DECODE_DIR="decoded_apk_debug"
          
          echo "Decoding $ACTUAL_APK_FILENAME into $DECODE_DIR for inspection..."
          apktool d "$ACTUAL_APK_FILENAME" -o "$DECODE_DIR" -f || echo "‚ö†Ô∏è apktool decode failed, attempting to continue..."
          
          APKTOOL_YAML_PATH="$DECODE_DIR/apktool.yml"
          if [ -f "$APKTOOL_YAML_PATH" ]; then
             echo "--- Contents of $APKTOOL_YAML_PATH ---"
             cat "$APKTOOL_YAML_PATH"
             echo "------------------------------------"
          else
             echo "apktool.yml not found in $DECODE_DIR after decode attempt."
          fi
          echo "APK_FILENAME_FOR_PUBLISH=$ACTUAL_APK_FILENAME" >> $GITHUB_ENV # Pass the name to the next step
          cd .. # Return to workspace root

      # --- Cleanup Before Publish ---
      - name: Clean up potential intermediate files
        run: |
          echo "Cleaning up ./release directory..."
          rm -f ./release/apktool.yml ./release/decoded_apk_debug/apktool.yml
          rm -rf ./release/decoded_apk_debug 
          echo "Contents of ./release after cleanup:"
          ls -l ./release
      
      # --- Inspect Final APK ---
      - name: Inspect APK Badging before Publish
        if: steps.find_aapt2.outputs.aapt2_path != '' # Only run if aapt2 was found
        env:
           # Get APK filename from the decode step's env var
           APK_FILENAME_ENV: ${{ steps.decode_for_debug.outputs.APK_FILENAME_FOR_PUBLISH || env.APK_FILENAME }} 
           # Get APK filename from the decode step's env var
           APK_FILENAME_ENV: ${{ steps.decode_for_debug.outputs.APK_FILENAME_FOR_PUBLISH || env.APK_FILENAME }} 
        run: |
           cd ./release
           AAPT2_CMD="${{ steps.find_aapt2.outputs.aapt2_path }}"
           # Use the env var passed down from decode step
           APK_FILE="$APK_FILENAME_ENV" 
           # Use the env var passed down from decode step
           APK_FILE="$APK_FILENAME_ENV" 

           if [ -z "$APK_FILE" ]; then
             echo "‚ùå APK_FILENAME_ENV environment variable not set or empty."
             # Fallback to finding it again if needed? Better to rely on the previous step.
             APK_FILE=$(find . -maxdepth 1 -name 'runstr-*.apk' -print -quit)
             if [ -z "$APK_FILE" ]; then
                echo "‚ùå Fallback failed: APK file (runstr-*.apk) not found in ./release directory for inspection."
                exit 1
             fi
             echo "Used fallback to find APK: $APK_FILE"
             echo "‚ùå APK_FILENAME_ENV environment variable not set or empty."
             # Fallback to finding it again if needed? Better to rely on the previous step.
             APK_FILE=$(find . -maxdepth 1 -name 'runstr-*.apk' -print -quit)
             if [ -z "$APK_FILE" ]; then
                echo "‚ùå Fallback failed: APK file (runstr-*.apk) not found in ./release directory for inspection."
                exit 1
             fi
             echo "Used fallback to find APK: $APK_FILE"
           fi
           
           
           if [ ! -f "$APK_FILE" ]; then
             echo "‚ùå APK file '$APK_FILE' not found in ./release directory for inspection."
             exit 1
           fi

           echo "--- Dumping badging info for $APK_FILE using $AAPT2_CMD ---"
           "$AAPT2_CMD" dump badging "$APK_FILE" || echo "‚ö†Ô∏è Failed to dump badging info."
           echo "---------------------------------------------------------"
           cd .. # Return to workspace root
      
      # --- Publish ---
      - name: Publish to Zapstore with Detailed Error Logging
        env:
          NSEC: ${{ secrets.NSEC }}
          APKSIGNER_PATH: ${{ env.APKSIGNER_PATH }}
          VERSION: ${{ needs.release_and_build.outputs.build_version }}
          # Get APK filename from the decode step's env var
          APK_FILENAME: ${{ steps.decode_for_debug.outputs.APK_FILENAME_FOR_PUBLISH || env.APK_FILENAME }}
          # Make sure these are still available or set earlier in this job
          ICON_FILENAME: ${{ env.ICON_FILENAME || 'runstr_logo.png' }} 
          NOTES_FILENAME: ${{ env.NOTES_FILENAME || 'release_notes.md' }} 
          # Make sure these are still available or set earlier in this job
          ICON_FILENAME: ${{ env.ICON_FILENAME || 'runstr_logo.png' }} 
          NOTES_FILENAME: ${{ env.NOTES_FILENAME || 'release_notes.md' }} 
        run: |
          cd ./release # Navigate into the directory with assets

          # Re-check required env vars are set
          if [ -z "$APK_FILENAME" ] || [ -z "$ICON_FILENAME" ] || [ -z "$NOTES_FILENAME" ]; then
             echo "‚ùå Error: Missing required filename env vars (APK_FILENAME, ICON_FILENAME, NOTES_FILENAME)"
             echo "APK: $APK_FILENAME, ICON: $ICON_FILENAME, NOTES: $NOTES_FILENAME"
             exit 1
          fi

          echo "Publishing v${VERSION} to Zapstore using apksigner at $APKSIGNER_PATH..."
          echo "Icon file: ${ICON_FILENAME}"
          echo "APK file: ${APK_FILENAME}"
          echo "Notes file: ${NOTES_FILENAME}"

          # Check files exist before publishing
          test -f "${ICON_FILENAME}" || { echo "‚ùå Icon file '${ICON_FILENAME}' not found!"; exit 1; }
          test -f "${APK_FILENAME}" || { echo "‚ùå APK file '${APK_FILENAME}' not found!"; exit 1; }
          test -f "${NOTES_FILENAME}" || { echo "‚ùå Notes file '${NOTES_FILENAME}' not found!"; exit 1; }

          # Verify APK has a signature (optional check)
          if [ -f "${APK_FILENAME}" ]; then
            echo "Checking APK signature..."
            if unzip -l "${APK_FILENAME}" | grep -q "META-INF/.*\\.RSA"; then
            if unzip -l "${APK_FILENAME}" | grep -q "META-INF/.*\\.RSA"; then
              echo "‚úÖ APK appears to be signed (found .RSA files)"
            else
              echo "‚ö†Ô∏è Warning: APK may not be properly signed (no .RSA files found)"
            fi
          fi

          # Attempt to publish to Zapstore, capture output and exit code
          echo "Attempting to publish to Zapstore..."
          set +e # Prevent script from exiting immediately on error
          PUBLISH_OUTPUT=$(APKSIGNER_PATH="$APKSIGNER_PATH" zapstore publish runstr \
            --daemon-mode \
            --overwrite-app \
            --overwrite-release \
            --icon "${ICON_FILENAME}" \
            -n "${NOTES_FILENAME}" \
            -a "${APK_FILENAME}" \
            -v "${VERSION}" 2>&1) # Redirect stderr to stdout to capture all output
          PUBLISH_EXIT_CODE=$?
          set -e # Re-enable immediate exit on error

          echo "--- Zapstore Publish Output --- ($PUBLISH_EXIT_CODE)"
          echo "$PUBLISH_OUTPUT"
          echo "-------------------------------"

          if [ $PUBLISH_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Zapstore publish failed with exit code $PUBLISH_EXIT_CODE"
            # Add more specific logging here if needed based on common errors
            if echo "$PUBLISH_OUTPUT" | grep -q "invalid apk metadata"; then
               echo "Failure seems related to APK metadata as suspected."
            fi
             # Consider adding more error checks based on output
             # Consider adding more error checks based on output
            exit $PUBLISH_EXIT_CODE # Ensure the step fails with the original exit code
          else
            echo "‚úÖ Successfully published version ${VERSION} to Zapstore!"
          fi

      - name: ‚úÖ Notify success
        if: ${{ success() }}
        run: |
          echo "üéâ RUNSTR v${{ needs.release_and_build.outputs.build_version }} published to Zapstore!"
          echo "üîó https://zapstore.dev/app/runstr"
